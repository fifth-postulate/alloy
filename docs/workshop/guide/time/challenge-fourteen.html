<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Challenge Fourteen - Alloy</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="../custom.css">

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="../title.html">Title</a></li><li class="chapter-item expanded affix "><a href="../expectations.html">What to expect</a></li><li class="chapter-item expanded affix "><li class="part-title">Introduction</li><li class="chapter-item expanded "><a href="../introduction/origin.html"><strong aria-hidden="true">1.</strong> Origin</a></li><li class="chapter-item expanded "><a href="../introduction/fascilitators.html"><strong aria-hidden="true">2.</strong> Facilitators</a></li><li class="chapter-item expanded "><a href="../introduction/organisation.html"><strong aria-hidden="true">3.</strong> Organization</a></li><li class="chapter-item expanded affix "><li class="part-title">Alloy</li><li class="chapter-item expanded "><a href="../#.html"><strong aria-hidden="true">4.</strong> First Steps</a></li><li class="chapter-item expanded "><a href="../#.html"><strong aria-hidden="true">5.</strong> Exploring the analyzer</a></li><li class="chapter-item expanded affix "><li class="part-title">Analyzing structure and operations</li><li class="chapter-item expanded "><a href="../#.html"><strong aria-hidden="true">6.</strong> An Address Book with aliases</a></li><li class="chapter-item expanded affix "><li class="part-title">Time</li><li class="chapter-item expanded "><a href="../time/alloy-and-time.html"><strong aria-hidden="true">7.</strong> Alloy and Time</a></li><li class="chapter-item expanded "><a href="../time/challenge-fourteen.html" class="active"><strong aria-hidden="true">8.</strong> Challenge Fourteen</a></li><li class="chapter-item expanded "><a href="../time/edentifier.html"><strong aria-hidden="true">9.</strong> The e.dentifier</a></li><li class="chapter-item expanded "><a href="../#.html"><strong aria-hidden="true">10.</strong> Incrementing a register</a></li><li class="chapter-item expanded "><a href="../#.html"><strong aria-hidden="true">11.</strong> Another way to write Frame Conditions</a></li><li class="chapter-item expanded affix "><li class="part-title">Appendices</li><li class="chapter-item expanded "><a href="../appendix/sources.html"><strong aria-hidden="true">12.</strong> Sources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Alloy</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="challenge-fourteen"><a class="header" href="#challenge-fourteen">Challenge Fourteen</a></h1>
<p><a href="https://wiki.c2.com/?ExtremeProgrammingChallengeFourteen">Challenge Fourteen</a>
was one of the challenges to determine whether the methods of Extreme
Programming (XP) and Test Driven Design (TDD) could also be applied to
concurrency problems.</p>
<p>In Challenge Fourteen, Tom Cargill posited some code that had a known bug and
challenged people to expose the bug by writing unit tests. It took 2 weeks and a
test setup with 11 threads, running the test 250 times to finally expose the
bug.</p>
<p>Concurrency problems are notoriously hard to test for. But let's see if we can
use Alloy to model this problem and find the problem in less than 2 weeks!</p>
<h2 id="the-code"><a class="header" href="#the-code">The code</a></h2>
<p>Here is the code that Tom Cargill provided, modeling a concurrent queue of
finite size, implemented as a ring buffer.</p>
<p>If a thread ties to read from an empty queue it waits until an element is added
to the queue, and if a thread tries to write to a full queue it waits until
there is room in the queue again.</p>
<p>Here is the code:</p>
<pre><code class="language-java">class BoundedBuffer {
    private Object[] buffer = new Object[4];
    private int putAt, takeAt, occupied;

    synchronized void put(Object x) throws InterruptedException {
        while (occupied == buffer.length) {
            wait();
        }
        notify();

        ++occupied;
        putAt %= buffer.length;
        buffer[putAt++] = x;
    }

    synchronized Object take() throws InterruptedException {
        while (occupied == 0) {
            wait();
        }
        notify();

        --occupied;
        takeAt %= buffer.length;
        return buffer[takeAt++];
    }
}
</code></pre>
<p>If you are an experienced Java programmer, you may be able to spot the bug
straight away. But let's go through the exercise of modeling this problem in
Alloy and see if we can find the bug that way.</p>
<h3 id="what-does-this-code-mean"><a class="header" href="#what-does-this-code-mean">What does this code mean?</a></h3>
<p>If you are not familiar with Java and its concurrency primitives, here is a
small recap of the most important concepts:</p>
<ul>
<li>Every Java object implicitly has an associated mutex and condition flag.</li>
<li><code>synchronized</code> makes sure that the method runs atomically: this implicitly
acquires and releases the mutex, so that no 2 <code>synchronized</code> methods of the same
object will execute at the same time.</li>
<li><code>wait()</code> puts the current thread to sleep and releases the mutex that
<code>synchronized</code> implicitly holds, so that another thread can acquire it.  It is
common to put the <code>wait()</code> inside a loop.</li>
<li><code>notify()</code> wakes up one of the waiting threads, so that it can try acquiring
the mutex again.</li>
</ul>
<h2 id="translating-to-alloy"><a class="header" href="#translating-to-alloy">Translating to Alloy</a></h2>
<p>We're going to translate this program into Alloy. First: the queue buffer.
We don't care about the values in the buffer, or exactly where they go (yet).
If we wanted to confirm that we read items from the queue in the same order
as we put them, we would model those parts as well, but for now we will ignore them.</p>
<p>Here is the start of the buffer:</p>
<pre><code class="language-alloy">one sig Buffer {
  -- Give the buffer a capacity, and an occupancy level that can change over time
  // ...
}

fact {
  -- The buffer has a nonzero capacity, and starts out empty
  // ...
}
</code></pre>
<p><strong>EXERCISE</strong>: write the state relations of the <code>Buffer</code> sig and their facts.</p>
<p>Next, the threads that will act on our buffer:</p>
<pre><code class="language-alloy">abstract sig Thread {
}
sig Writer extends Thread {
}
sig Reader extends Thread {
}

-- True if the given thread is sleeping
-- We will use this to test our code.
pred isSleeping[t: Thread] {
  // ...
}

-- Assert that all threads are awake. This will be our
-- initialization condition later.
pred allThreadsAwake {
  no t: Thread | t.isSleeping
}
</code></pre>
<p>We need to keep track of which threads are awake and which are asleep.</p>
<p><strong>EXERCISE</strong>: add relation to keep track of which threads are awake and which
are asleep at a point in time.  You could make a property mapping a <code>Thread</code> to
a <code>Bool</code>, or you could make a sig for global variables that holds a set of
<code>Thread</code>s.</p>
<p>We are now going to implement the <code>wait()</code> and <code>notify()</code> primitives:</p>
<pre><code class="language-alloy">-- Put a single thread to sleep
pred wait[t: Thread] {
  // ...
}

-- If any threads are sleeping, wake one
pred notify {
  // ...
}

-- Testing the wait predicate
run WaitIsSatisfiable { all t: Thread | t.wait }
check TestWait {
  -- After we call wait on a thread, it should be asleep the next tick
  all t: Thread | t.wait =&gt; after t.isSleeping
}

-- Testing the notify predicate
run NotifyIsSatisfiable { notify }
check TestNotify {
  -- After calling notify...
  notify =&gt; {
    -- All threads that are still sleeping were at least sleeping before notify
    -- was called.
    all t: Thread | (after t.isSleeping) =&gt; t.isSleeping

    -- If there are any threads, then at least one of them is awake.
    some Thread =&gt; after some t: Thread | not t.isSleeping
  }
}
</code></pre>
<p>Instead of immediately declaring it as an initialization <code>fact</code>, we made
<code>allThreadsAwake</code> a separate predicate. That way, we can avoid calling it in our
tests of <code>wait</code> and <code>notify</code>, and explore their behavior in a state of mixed
sleeping and awake threads without having to do additional state manipulation.</p>
<p><strong>EXERCISE</strong>: implement the predicates above. They will involve a
time step, so you will prime a variable (<code>myvar'</code>) to update the value of some
relation. Use the provided commands to check your implementation. Did you
see any unexpected behavior? (Remember that if you don't constrain the
next state of a variable, the analyzer is allowed to pick any value!)</p>
<h2 id="what-do-we-want-to-check"><a class="header" href="#what-do-we-want-to-check">What do we want to check?</a></h2>
<p>We are now going to model the <code>put</code> and <code>take</code> methods. Here is the skeleton:</p>
<pre><code class="language-alloy">-- Add to the buffer's occupancy if it is not full yet, otherwise sleep.
pred put[w: Writer] {
  (Buffer.occupied = Buffer.capacity) implies {
    // ...
  } else {
    // ...
  }
}

-- Reduce one from the buffer's occupancy if it is nonempty, otherwise sleep
pred take[r: Reader] {
  (Buffer.occupied = 0) implies {
    // ...
  } else {
    // ...
  }
}

-- Call put or take as appropriate given a Thread
pred stepThread[t: Thread] {
  t in Writer =&gt; put[t]
  t in Reader =&gt; take[t]
}

-- Take an arbitrary awake thread, and make it take a step
pred stepAnyThread {
  (some t: Thread | not t.isSleeping) implies {
    some t: not t.isSleeping =&gt; stepThread[t]
  } else {
    -- If no threads are awake no progress can be made anymore.
    -- We need an explicit frame condition to say that in the next state all
    -- threads are still sleeping and also our buffer hasn't changed.
    after all t: Thread | t.isSleeping

    -- If you picked a different variable name here you need to change this
    Buffer.occupied' = Buffer.occupied
  }
}
</code></pre>
<p>Fortunately, the predicates can be quite straightforward: as long as we keep
calling <code>put</code> and <code>take</code> infinitely in a loop, the <code>synchronized/while/wait</code>
ensures that the entire function will execute in one indivisible step if the
condition of the <code>while</code> is satisfied.</p>
<p>In the next section, we will look at some processes that don't execute in
a single indivisible step, which need some more bookkeeping.</p>
<p><strong>EXERCISE</strong>: implement the <code>put</code> and <code>take</code> predicates. Watch out for
the integer addition! You need to write <code>plus[x, y]</code> (or <code>x.plus[y]</code>),
because <code>x + y</code> means set union, not addition!</p>
<h2 id="finding-the-bug"><a class="header" href="#finding-the-bug">Finding the bug</a></h2>
<p>We have now implemented everything! It's time to see if we can find the bug.</p>
<p>First, let's see if we can generate some interesting traces to see if
everything works. We'll put the entire setup of our spec into a <code>pred</code> so
that we can first <code>run</code> it, and then re-use it in a <code>check</code>.</p>
<pre><code class="language-alloy">pred TraceSomeThreads {
  -- Have both types of threads
  some Reader
  some Writer

  -- All threads start out awake
  allThreadsAwake

  -- At every time step, exactly one thread makes progress
  always stepAnyThread
}
run TraceSomeThreads
</code></pre>
<p>If that worked, we are now ready to go check for the bug:</p>
<pre><code class="language-alloy">check FindTheBug {
  TraceSomeThreads =&gt; {
    -- Write some invariants that we want this system to satisfy.
    always // ...
  }
}
</code></pre>
<p><strong>EXERCISE</strong>: write one or more invariants in the <code>check</code> block to make sure our
system satisfies those invariants at every point in time, then run Alloy to see
if it satisfies them. If you're unsure about what to check for, consider this:
what do we definitely <em>not</em> want to happen in a system with multiple threads?</p>
<p>In our case, the counterexample took 8 time steps to surface a violation of the
invariant. It involves 2 readers and 1 writer.</p>
<p><strong>EXERCISE</strong>: what happened? Step throug the counterexample, observe the state
changes at every step, and describe what happened. You can play a little with
the visualizer settings to make it easier to read.</p>
<h2 id="fixing-the-bug"><a class="header" href="#fixing-the-bug">Fixing the bug</a></h2>
<p>Now that we have found the bug, the next question is how to fix it. Maybe you
have a good idea, or you know the pattern already.</p>
<p>It turns out that Java objects also have another method to wake threads:</p>
<pre><code>public void notifyAll()
    Wakes up all threads that are waiting on this object's monitor.
</code></pre>
<pre><code class="language-alloy">-- Wake all threads that are sleeping
pred notifyAll {
  // ...
}
</code></pre>
<p><strong>EXERCISE</strong>: implement <code>notifyAll</code>, then update the code to use the new
*predicate, and confirm that
it fixes the bug (or at least, that the bug doesn't surface in 10 time steps and
with however many objects you checked!). Did you need to change all occurrences
of <code>notify</code>, or can you get away with just changing one? What would you do in
practice?</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../time/alloy-and-time.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../time/edentifier.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../time/alloy-and-time.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../time/edentifier.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
